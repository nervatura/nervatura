// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type APIClient interface {
	// Logs in user by username and password
	UserLogin(ctx context.Context, in *RequestUserLogin, opts ...grpc.CallOption) (*ResponseUserLogin, error)
	// User (employee or customer) password change.
	UserPassword(ctx context.Context, in *RequestUserPassword, opts ...grpc.CallOption) (*ResponseEmpty, error)
	// JWT token auth.
	TokenLogin(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseTokenLogin, error)
	// Refreshes JWT token by checking at database whether refresh token exists.
	TokenRefresh(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseTokenRefresh, error)
	// Decoded JWT token but doesn't validate the signature.
	TokenDecode(ctx context.Context, in *RequestTokenDecode, opts ...grpc.CallOption) (*ResponseTokenDecode, error)
	// Get returns one or more records
	Get(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*ResponseGet, error)
	// Add/update one or more items
	Update(ctx context.Context, in *RequestUpdate, opts ...grpc.CallOption) (*ResponseUpdate, error)
	// Delete an item
	Delete(ctx context.Context, in *RequestDelete, opts ...grpc.CallOption) (*ResponseEmpty, error)
	// Run raw SQL queries in safe mode
	View(ctx context.Context, in *RequestView, opts ...grpc.CallOption) (*ResponseView, error)
	// Call a server-side function
	Function(ctx context.Context, in *RequestFunction, opts ...grpc.CallOption) (*ResponseFunction, error)
	// Create and download a Nervatura Report
	Report(ctx context.Context, in *RequestReport, opts ...grpc.CallOption) (*ResponseReport, error)
	// List all available Nervatura Report. Admin user group membership required.
	ReportList(ctx context.Context, in *RequestReportList, opts ...grpc.CallOption) (*ResponseReportList, error)
	// Install a report to the database. Admin user group membership required.
	ReportInstall(ctx context.Context, in *RequestReportInstall, opts ...grpc.CallOption) (*ResponseReportInstall, error)
	// Delete a report from the database. Admin user group membership required.
	ReportDelete(ctx context.Context, in *RequestReportDelete, opts ...grpc.CallOption) (*ResponseEmpty, error)
	// Create a new Nervatura database
	DatabaseCreate(ctx context.Context, in *RequestDatabaseCreate, opts ...grpc.CallOption) (*ResponseDatabaseCreate, error)
}

type aPIClient struct {
	cc grpc.ClientConnInterface
}

func NewAPIClient(cc grpc.ClientConnInterface) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) UserLogin(ctx context.Context, in *RequestUserLogin, opts ...grpc.CallOption) (*ResponseUserLogin, error) {
	out := new(ResponseUserLogin)
	err := c.cc.Invoke(ctx, "/nervatura.API/UserLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) UserPassword(ctx context.Context, in *RequestUserPassword, opts ...grpc.CallOption) (*ResponseEmpty, error) {
	out := new(ResponseEmpty)
	err := c.cc.Invoke(ctx, "/nervatura.API/UserPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenLogin(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseTokenLogin, error) {
	out := new(ResponseTokenLogin)
	err := c.cc.Invoke(ctx, "/nervatura.API/TokenLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenRefresh(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseTokenRefresh, error) {
	out := new(ResponseTokenRefresh)
	err := c.cc.Invoke(ctx, "/nervatura.API/TokenRefresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenDecode(ctx context.Context, in *RequestTokenDecode, opts ...grpc.CallOption) (*ResponseTokenDecode, error) {
	out := new(ResponseTokenDecode)
	err := c.cc.Invoke(ctx, "/nervatura.API/TokenDecode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Get(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*ResponseGet, error) {
	out := new(ResponseGet)
	err := c.cc.Invoke(ctx, "/nervatura.API/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Update(ctx context.Context, in *RequestUpdate, opts ...grpc.CallOption) (*ResponseUpdate, error) {
	out := new(ResponseUpdate)
	err := c.cc.Invoke(ctx, "/nervatura.API/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Delete(ctx context.Context, in *RequestDelete, opts ...grpc.CallOption) (*ResponseEmpty, error) {
	out := new(ResponseEmpty)
	err := c.cc.Invoke(ctx, "/nervatura.API/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) View(ctx context.Context, in *RequestView, opts ...grpc.CallOption) (*ResponseView, error) {
	out := new(ResponseView)
	err := c.cc.Invoke(ctx, "/nervatura.API/View", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Function(ctx context.Context, in *RequestFunction, opts ...grpc.CallOption) (*ResponseFunction, error) {
	out := new(ResponseFunction)
	err := c.cc.Invoke(ctx, "/nervatura.API/Function", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Report(ctx context.Context, in *RequestReport, opts ...grpc.CallOption) (*ResponseReport, error) {
	out := new(ResponseReport)
	err := c.cc.Invoke(ctx, "/nervatura.API/Report", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ReportList(ctx context.Context, in *RequestReportList, opts ...grpc.CallOption) (*ResponseReportList, error) {
	out := new(ResponseReportList)
	err := c.cc.Invoke(ctx, "/nervatura.API/ReportList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ReportInstall(ctx context.Context, in *RequestReportInstall, opts ...grpc.CallOption) (*ResponseReportInstall, error) {
	out := new(ResponseReportInstall)
	err := c.cc.Invoke(ctx, "/nervatura.API/ReportInstall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ReportDelete(ctx context.Context, in *RequestReportDelete, opts ...grpc.CallOption) (*ResponseEmpty, error) {
	out := new(ResponseEmpty)
	err := c.cc.Invoke(ctx, "/nervatura.API/ReportDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DatabaseCreate(ctx context.Context, in *RequestDatabaseCreate, opts ...grpc.CallOption) (*ResponseDatabaseCreate, error) {
	out := new(ResponseDatabaseCreate)
	err := c.cc.Invoke(ctx, "/nervatura.API/DatabaseCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
// All implementations must embed UnimplementedAPIServer
// for forward compatibility
type APIServer interface {
	// Logs in user by username and password
	UserLogin(context.Context, *RequestUserLogin) (*ResponseUserLogin, error)
	// User (employee or customer) password change.
	UserPassword(context.Context, *RequestUserPassword) (*ResponseEmpty, error)
	// JWT token auth.
	TokenLogin(context.Context, *RequestEmpty) (*ResponseTokenLogin, error)
	// Refreshes JWT token by checking at database whether refresh token exists.
	TokenRefresh(context.Context, *RequestEmpty) (*ResponseTokenRefresh, error)
	// Decoded JWT token but doesn't validate the signature.
	TokenDecode(context.Context, *RequestTokenDecode) (*ResponseTokenDecode, error)
	// Get returns one or more records
	Get(context.Context, *RequestGet) (*ResponseGet, error)
	// Add/update one or more items
	Update(context.Context, *RequestUpdate) (*ResponseUpdate, error)
	// Delete an item
	Delete(context.Context, *RequestDelete) (*ResponseEmpty, error)
	// Run raw SQL queries in safe mode
	View(context.Context, *RequestView) (*ResponseView, error)
	// Call a server-side function
	Function(context.Context, *RequestFunction) (*ResponseFunction, error)
	// Create and download a Nervatura Report
	Report(context.Context, *RequestReport) (*ResponseReport, error)
	// List all available Nervatura Report. Admin user group membership required.
	ReportList(context.Context, *RequestReportList) (*ResponseReportList, error)
	// Install a report to the database. Admin user group membership required.
	ReportInstall(context.Context, *RequestReportInstall) (*ResponseReportInstall, error)
	// Delete a report from the database. Admin user group membership required.
	ReportDelete(context.Context, *RequestReportDelete) (*ResponseEmpty, error)
	// Create a new Nervatura database
	DatabaseCreate(context.Context, *RequestDatabaseCreate) (*ResponseDatabaseCreate, error)
	mustEmbedUnimplementedAPIServer()
}

// UnimplementedAPIServer must be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (UnimplementedAPIServer) UserLogin(context.Context, *RequestUserLogin) (*ResponseUserLogin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedAPIServer) UserPassword(context.Context, *RequestUserPassword) (*ResponseEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserPassword not implemented")
}
func (UnimplementedAPIServer) TokenLogin(context.Context, *RequestEmpty) (*ResponseTokenLogin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenLogin not implemented")
}
func (UnimplementedAPIServer) TokenRefresh(context.Context, *RequestEmpty) (*ResponseTokenRefresh, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenRefresh not implemented")
}
func (UnimplementedAPIServer) TokenDecode(context.Context, *RequestTokenDecode) (*ResponseTokenDecode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenDecode not implemented")
}
func (UnimplementedAPIServer) Get(context.Context, *RequestGet) (*ResponseGet, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAPIServer) Update(context.Context, *RequestUpdate) (*ResponseUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedAPIServer) Delete(context.Context, *RequestDelete) (*ResponseEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAPIServer) View(context.Context, *RequestView) (*ResponseView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method View not implemented")
}
func (UnimplementedAPIServer) Function(context.Context, *RequestFunction) (*ResponseFunction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Function not implemented")
}
func (UnimplementedAPIServer) Report(context.Context, *RequestReport) (*ResponseReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Report not implemented")
}
func (UnimplementedAPIServer) ReportList(context.Context, *RequestReportList) (*ResponseReportList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportList not implemented")
}
func (UnimplementedAPIServer) ReportInstall(context.Context, *RequestReportInstall) (*ResponseReportInstall, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportInstall not implemented")
}
func (UnimplementedAPIServer) ReportDelete(context.Context, *RequestReportDelete) (*ResponseEmpty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportDelete not implemented")
}
func (UnimplementedAPIServer) DatabaseCreate(context.Context, *RequestDatabaseCreate) (*ResponseDatabaseCreate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatabaseCreate not implemented")
}
func (UnimplementedAPIServer) mustEmbedUnimplementedAPIServer() {}

// UnsafeAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to APIServer will
// result in compilation errors.
type UnsafeAPIServer interface {
	mustEmbedUnimplementedAPIServer()
}

func RegisterAPIServer(s grpc.ServiceRegistrar, srv APIServer) {
	s.RegisterService(&API_ServiceDesc, srv)
}

func _API_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestUserLogin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/UserLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).UserLogin(ctx, req.(*RequestUserLogin))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_UserPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestUserPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).UserPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/UserPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).UserPassword(ctx, req.(*RequestUserPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEmpty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/TokenLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenLogin(ctx, req.(*RequestEmpty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenRefresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEmpty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenRefresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/TokenRefresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenRefresh(ctx, req.(*RequestEmpty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTokenDecode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/TokenDecode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenDecode(ctx, req.(*RequestTokenDecode))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Get(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Update(ctx, req.(*RequestUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDelete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Delete(ctx, req.(*RequestDelete))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_View_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).View(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/View",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).View(ctx, req.(*RequestView))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Function_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFunction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Function(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/Function",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Function(ctx, req.(*RequestFunction))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Report_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReport)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Report(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/Report",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Report(ctx, req.(*RequestReport))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ReportList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReportList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ReportList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/ReportList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ReportList(ctx, req.(*RequestReportList))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ReportInstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReportInstall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ReportInstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/ReportInstall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ReportInstall(ctx, req.(*RequestReportInstall))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ReportDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReportDelete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ReportDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/ReportDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ReportDelete(ctx, req.(*RequestReportDelete))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DatabaseCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDatabaseCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DatabaseCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nervatura.API/DatabaseCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DatabaseCreate(ctx, req.(*RequestDatabaseCreate))
	}
	return interceptor(ctx, in, info, handler)
}

// API_ServiceDesc is the grpc.ServiceDesc for API service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var API_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nervatura.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _API_UserLogin_Handler,
		},
		{
			MethodName: "UserPassword",
			Handler:    _API_UserPassword_Handler,
		},
		{
			MethodName: "TokenLogin",
			Handler:    _API_TokenLogin_Handler,
		},
		{
			MethodName: "TokenRefresh",
			Handler:    _API_TokenRefresh_Handler,
		},
		{
			MethodName: "TokenDecode",
			Handler:    _API_TokenDecode_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _API_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _API_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _API_Delete_Handler,
		},
		{
			MethodName: "View",
			Handler:    _API_View_Handler,
		},
		{
			MethodName: "Function",
			Handler:    _API_Function_Handler,
		},
		{
			MethodName: "Report",
			Handler:    _API_Report_Handler,
		},
		{
			MethodName: "ReportList",
			Handler:    _API_ReportList_Handler,
		},
		{
			MethodName: "ReportInstall",
			Handler:    _API_ReportInstall_Handler,
		},
		{
			MethodName: "ReportDelete",
			Handler:    _API_ReportDelete_Handler,
		},
		{
			MethodName: "DatabaseCreate",
			Handler:    _API_DatabaseCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
