// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.14.0
// source: pkg/service/grpc/proto/store.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	API_AuthLogin_FullMethodName         = "/nervatura.API/AuthLogin"
	API_AuthUpdate_FullMethodName        = "/nervatura.API/AuthUpdate"
	API_AuthGet_FullMethodName           = "/nervatura.API/AuthGet"
	API_AuthPassword_FullMethodName      = "/nervatura.API/AuthPassword"
	API_AuthPasswordReset_FullMethodName = "/nervatura.API/AuthPasswordReset"
	API_TokenLogin_FullMethodName        = "/nervatura.API/TokenLogin"
	API_TokenRefresh_FullMethodName      = "/nervatura.API/TokenRefresh"
	API_TokenDecode_FullMethodName       = "/nervatura.API/TokenDecode"
	API_Database_FullMethodName          = "/nervatura.API/Database"
	API_Delete_FullMethodName            = "/nervatura.API/Delete"
	API_Function_FullMethodName          = "/nervatura.API/Function"
	API_View_FullMethodName              = "/nervatura.API/View"
	API_ConfigUpdate_FullMethodName      = "/nervatura.API/ConfigUpdate"
	API_ConfigGet_FullMethodName         = "/nervatura.API/ConfigGet"
	API_ConfigQuery_FullMethodName       = "/nervatura.API/ConfigQuery"
	API_CurrencyUpdate_FullMethodName    = "/nervatura.API/CurrencyUpdate"
	API_CurrencyGet_FullMethodName       = "/nervatura.API/CurrencyGet"
	API_CurrencyQuery_FullMethodName     = "/nervatura.API/CurrencyQuery"
	API_CustomerUpdate_FullMethodName    = "/nervatura.API/CustomerUpdate"
	API_CustomerGet_FullMethodName       = "/nervatura.API/CustomerGet"
	API_CustomerQuery_FullMethodName     = "/nervatura.API/CustomerQuery"
	API_EmployeeUpdate_FullMethodName    = "/nervatura.API/EmployeeUpdate"
	API_EmployeeGet_FullMethodName       = "/nervatura.API/EmployeeGet"
	API_EmployeeQuery_FullMethodName     = "/nervatura.API/EmployeeQuery"
	API_ItemUpdate_FullMethodName        = "/nervatura.API/ItemUpdate"
	API_ItemGet_FullMethodName           = "/nervatura.API/ItemGet"
	API_ItemQuery_FullMethodName         = "/nervatura.API/ItemQuery"
	API_LinkUpdate_FullMethodName        = "/nervatura.API/LinkUpdate"
	API_LinkGet_FullMethodName           = "/nervatura.API/LinkGet"
	API_LinkQuery_FullMethodName         = "/nervatura.API/LinkQuery"
	API_LogGet_FullMethodName            = "/nervatura.API/LogGet"
	API_LogQuery_FullMethodName          = "/nervatura.API/LogQuery"
	API_MovementUpdate_FullMethodName    = "/nervatura.API/MovementUpdate"
	API_MovementGet_FullMethodName       = "/nervatura.API/MovementGet"
	API_MovementQuery_FullMethodName     = "/nervatura.API/MovementQuery"
	API_PaymentUpdate_FullMethodName     = "/nervatura.API/PaymentUpdate"
	API_PaymentGet_FullMethodName        = "/nervatura.API/PaymentGet"
	API_PaymentQuery_FullMethodName      = "/nervatura.API/PaymentQuery"
	API_PlaceUpdate_FullMethodName       = "/nervatura.API/PlaceUpdate"
	API_PlaceGet_FullMethodName          = "/nervatura.API/PlaceGet"
	API_PlaceQuery_FullMethodName        = "/nervatura.API/PlaceQuery"
	API_PriceUpdate_FullMethodName       = "/nervatura.API/PriceUpdate"
	API_PriceGet_FullMethodName          = "/nervatura.API/PriceGet"
	API_PriceQuery_FullMethodName        = "/nervatura.API/PriceQuery"
	API_ProductUpdate_FullMethodName     = "/nervatura.API/ProductUpdate"
	API_ProductGet_FullMethodName        = "/nervatura.API/ProductGet"
	API_ProductQuery_FullMethodName      = "/nervatura.API/ProductQuery"
	API_ProjectUpdate_FullMethodName     = "/nervatura.API/ProjectUpdate"
	API_ProjectGet_FullMethodName        = "/nervatura.API/ProjectGet"
	API_ProjectQuery_FullMethodName      = "/nervatura.API/ProjectQuery"
	API_RateUpdate_FullMethodName        = "/nervatura.API/RateUpdate"
	API_RateGet_FullMethodName           = "/nervatura.API/RateGet"
	API_RateQuery_FullMethodName         = "/nervatura.API/RateQuery"
	API_TaxUpdate_FullMethodName         = "/nervatura.API/TaxUpdate"
	API_TaxGet_FullMethodName            = "/nervatura.API/TaxGet"
	API_TaxQuery_FullMethodName          = "/nervatura.API/TaxQuery"
	API_ToolUpdate_FullMethodName        = "/nervatura.API/ToolUpdate"
	API_ToolGet_FullMethodName           = "/nervatura.API/ToolGet"
	API_ToolQuery_FullMethodName         = "/nervatura.API/ToolQuery"
	API_TransUpdate_FullMethodName       = "/nervatura.API/TransUpdate"
	API_TransGet_FullMethodName          = "/nervatura.API/TransGet"
	API_TransQuery_FullMethodName        = "/nervatura.API/TransQuery"
)

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Nervatura gRPC API
type APIClient interface {
	// Login by username and password and get access token
	AuthLogin(ctx context.Context, in *RequestAuthLogin, opts ...grpc.CallOption) (*ResponseAuthLogin, error)
	// Update or create user account.
	// If id or existing code is set, the user is updated, otherwise a new user is created.
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthUpdate(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error)
	// Get user account by database id or code (unique key)
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Auth, error)
	// Change token user password
	AuthPassword(ctx context.Context, in *RequestPasswordChange, opts ...grpc.CallOption) (*ResponseStatus, error)
	// Reset a user password and result a new password
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthPasswordReset(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*ResponseStatus, error)
	// Login by access token. Returns token user
	TokenLogin(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*Auth, error)
	// Refresh access token
	TokenRefresh(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseAuthLogin, error)
	// Decode JWT access token but doesn't validate the signature
	TokenDecode(ctx context.Context, in *RequestTokenDecode, opts ...grpc.CallOption) (*ResponseTokenDecode, error)
	// Create new nervatura database schema
	Database(ctx context.Context, in *RequestDatabase, opts ...grpc.CallOption) (*JsonBytes, error)
	// Delete data by database id or code (unique key)
	// Only admin users can delete configurations except for CONFIG_PRINT_QUEUE and CONFIG_PATTERN
	// Auth user cannot be deleted, only disabled by admin users
	Delete(ctx context.Context, in *RequestDelete, opts ...grpc.CallOption) (*ResponseStatus, error)
	// Call a server side function and get the result
	// Example: create new PDF invoice, send email or get a product price
	Function(ctx context.Context, in *RequestFunction, opts ...grpc.CallOption) (*JsonBytes, error)
	// Get a predefined view by name
	View(ctx context.Context, in *RequestView, opts ...grpc.CallOption) (*JsonBytes, error)
	// Update (replace) or create configuration
	// If id or existing code is set, the configuration is updated, otherwise a new configuration is created.
	// Only admin users can create or update configurations except for CONFIG_PRINT_QUEUE and CONFIG_PATTERN
	ConfigUpdate(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Config, error)
	// Get configuration by database id or code (unique key)
	ConfigGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Config, error)
	// Get configurations by query parameters
	// Valid filters: config_type
	ConfigQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Configs, error)
	// Update (replace) or create currency
	// If id or existing code is set, the currency is updated, otherwise a new currency is created.
	CurrencyUpdate(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*Currency, error)
	// Get currency by database id or code (unique key)
	CurrencyGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Currency, error)
	// Get currencies by query parameters
	// Valid filters: tag
	CurrencyQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Currencies, error)
	// Update (replace) or create customer
	// If id or existing code is set, the customer is updated, otherwise a new customer is created.
	CustomerUpdate(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error)
	// Get customer by database id or code (unique key)
	CustomerGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Customer, error)
	// Get customers by query parameters
	// Valid filters: customer_type, customer_name, tag
	CustomerQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Customers, error)
	// Update (replace) or create employee
	// If id or existing code is set, the employee is updated, otherwise a new employee is created.
	EmployeeUpdate(ctx context.Context, in *Employee, opts ...grpc.CallOption) (*Employee, error)
	// Get employee by database id or code (unique key)
	EmployeeGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Employee, error)
	// Get employees by query parameters
	// Valid filters: tag
	EmployeeQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Employees, error)
	// Update (replace) or create item
	// If id or existing code is set, the item is updated, otherwise a new item is created.
	ItemUpdate(ctx context.Context, in *Item, opts ...grpc.CallOption) (*Item, error)
	// Get item by database id or code (unique key)
	ItemGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Item, error)
	// Get items by query parameters
	// Valid filters: trans_code, product_code, tag
	ItemQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Items, error)
	// Update (replace) or create link
	// If id or existing code is set, the link is updated, otherwise a new link is created.
	LinkUpdate(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Link, error)
	// Get link by database id or code (unique key)
	LinkGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Link, error)
	// Get links by query parameters
	// Valid filters: link_type_1, link_code_1, link_type_2, link_code_2, tag
	LinkQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Links, error)
	// Get log by database id or code (unique key)
	LogGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Log, error)
	// Get logs by query parameters
	// Valid filters: log_type, ref_type, ref_code, tag
	LogQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Logs, error)
	// Update (replace) or create movement
	// If id or existing code is set, the movement is updated, otherwise a new movement is created.
	MovementUpdate(ctx context.Context, in *Movement, opts ...grpc.CallOption) (*Movement, error)
	// Get movement by database id or code (unique key)
	MovementGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Movement, error)
	// Get movements by query parameters
	// Valid filters: trans_code, movement_type, tag
	MovementQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Movements, error)
	// Update (replace) or create payment
	// If id or existing code is set, the payment is updated, otherwise a new payment is created.
	PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error)
	// Get payment by database id or code (unique key)
	PaymentGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Payment, error)
	// Get payments by query parameters
	// Valid filters: trans_code, paid_date, tag
	PaymentQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Payments, error)
	// Update (replace) or create place
	// If id or existing code is set, the place is updated, otherwise a new place is created.
	PlaceUpdate(ctx context.Context, in *Place, opts ...grpc.CallOption) (*Place, error)
	// Get place by database id or code (unique key)
	PlaceGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Place, error)
	// Get places by query parameters
	// Valid filters: place_type, place_name, tag
	PlaceQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Places, error)
	// Update (replace) or create price
	// If id or existing code is set, the price is updated, otherwise a new price is created.
	PriceUpdate(ctx context.Context, in *Price, opts ...grpc.CallOption) (*Price, error)
	// Get price by database id or code (unique key)
	PriceGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Price, error)
	// Get prices by query parameters
	// Valid filters: price_type, product_code, currency_code, customer_code, tag
	PriceQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Prices, error)
	// Update (replace) or create product
	// If id or existing code is set, the product is updated, otherwise a new product is created.
	ProductUpdate(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error)
	// Get product by database id or code (unique key)
	ProductGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Product, error)
	// Get products by query parameters
	// Valid filters: product_type, product_name, tag
	ProductQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Products, error)
	// Update (replace) or create project
	// If id or existing code is set, the project is updated, otherwise a new project is created.
	ProjectUpdate(ctx context.Context, in *Project, opts ...grpc.CallOption) (*Project, error)
	// Get project by database id or code (unique key)
	ProjectGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Project, error)
	// Get projects by query parameters
	// Valid filters: project_name, customer_code, tag
	ProjectQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Projects, error)
	// Update (replace) or create rate
	// If id or existing code is set, the rate is updated, otherwise a new rate is created.
	RateUpdate(ctx context.Context, in *Rate, opts ...grpc.CallOption) (*Rate, error)
	// Get rate by database id or code (unique key)
	RateGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Rate, error)
	// Get rates by query parameters
	// Valid filters: rate_type, currency_code, tag
	RateQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Rates, error)
	// Update (replace) or create tax
	// If id or existing code is set, the tax is updated, otherwise a new tax is created.
	TaxUpdate(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error)
	// Get tax by database id or code (unique key)
	TaxGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Tax, error)
	// Get taxes by query parameters
	// Valid filters: tag
	TaxQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Taxes, error)
	// Update (replace) or create tool
	// If id or existing code is set, the tool is updated, otherwise a new tool is created.
	ToolUpdate(ctx context.Context, in *Tool, opts ...grpc.CallOption) (*Tool, error)
	// Get tool by database id or code (unique key)
	ToolGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Tool, error)
	// Get tools by query parameters
	// Valid filters: product_code, description, tag
	ToolQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Tools, error)
	// Update (replace) or create transaction
	// If id or existing code is set, the transaction is updated, otherwise a new transaction is created.
	TransUpdate(ctx context.Context, in *Trans, opts ...grpc.CallOption) (*Trans, error)
	// Get transaction by database id or code (unique key)
	TransGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Trans, error)
	// Get transactions by query parameters
	// Valid filters: trans_type, direction, trans_date, tag
	TransQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Transactions, error)
}

type aPIClient struct {
	cc grpc.ClientConnInterface
}

func NewAPIClient(cc grpc.ClientConnInterface) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) AuthLogin(ctx context.Context, in *RequestAuthLogin, opts ...grpc.CallOption) (*ResponseAuthLogin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseAuthLogin)
	err := c.cc.Invoke(ctx, API_AuthLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) AuthUpdate(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth)
	err := c.cc.Invoke(ctx, API_AuthUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) AuthGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Auth, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth)
	err := c.cc.Invoke(ctx, API_AuthGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) AuthPassword(ctx context.Context, in *RequestPasswordChange, opts ...grpc.CallOption) (*ResponseStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseStatus)
	err := c.cc.Invoke(ctx, API_AuthPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) AuthPasswordReset(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*ResponseStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseStatus)
	err := c.cc.Invoke(ctx, API_AuthPasswordReset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenLogin(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*Auth, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Auth)
	err := c.cc.Invoke(ctx, API_TokenLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenRefresh(ctx context.Context, in *RequestEmpty, opts ...grpc.CallOption) (*ResponseAuthLogin, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseAuthLogin)
	err := c.cc.Invoke(ctx, API_TokenRefresh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TokenDecode(ctx context.Context, in *RequestTokenDecode, opts ...grpc.CallOption) (*ResponseTokenDecode, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseTokenDecode)
	err := c.cc.Invoke(ctx, API_TokenDecode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Database(ctx context.Context, in *RequestDatabase, opts ...grpc.CallOption) (*JsonBytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonBytes)
	err := c.cc.Invoke(ctx, API_Database_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Delete(ctx context.Context, in *RequestDelete, opts ...grpc.CallOption) (*ResponseStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseStatus)
	err := c.cc.Invoke(ctx, API_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Function(ctx context.Context, in *RequestFunction, opts ...grpc.CallOption) (*JsonBytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonBytes)
	err := c.cc.Invoke(ctx, API_Function_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) View(ctx context.Context, in *RequestView, opts ...grpc.CallOption) (*JsonBytes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JsonBytes)
	err := c.cc.Invoke(ctx, API_View_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ConfigUpdate(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Config, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config)
	err := c.cc.Invoke(ctx, API_ConfigUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ConfigGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Config, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Config)
	err := c.cc.Invoke(ctx, API_ConfigGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ConfigQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Configs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Configs)
	err := c.cc.Invoke(ctx, API_ConfigQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CurrencyUpdate(ctx context.Context, in *Currency, opts ...grpc.CallOption) (*Currency, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Currency)
	err := c.cc.Invoke(ctx, API_CurrencyUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CurrencyGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Currency, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Currency)
	err := c.cc.Invoke(ctx, API_CurrencyGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CurrencyQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Currencies, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Currencies)
	err := c.cc.Invoke(ctx, API_CurrencyQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CustomerUpdate(ctx context.Context, in *Customer, opts ...grpc.CallOption) (*Customer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Customer)
	err := c.cc.Invoke(ctx, API_CustomerUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CustomerGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Customer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Customer)
	err := c.cc.Invoke(ctx, API_CustomerGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CustomerQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Customers, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Customers)
	err := c.cc.Invoke(ctx, API_CustomerQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) EmployeeUpdate(ctx context.Context, in *Employee, opts ...grpc.CallOption) (*Employee, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Employee)
	err := c.cc.Invoke(ctx, API_EmployeeUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) EmployeeGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Employee, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Employee)
	err := c.cc.Invoke(ctx, API_EmployeeGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) EmployeeQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Employees, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Employees)
	err := c.cc.Invoke(ctx, API_EmployeeQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ItemUpdate(ctx context.Context, in *Item, opts ...grpc.CallOption) (*Item, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Item)
	err := c.cc.Invoke(ctx, API_ItemUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ItemGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Item, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Item)
	err := c.cc.Invoke(ctx, API_ItemGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ItemQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Items, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Items)
	err := c.cc.Invoke(ctx, API_ItemQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) LinkUpdate(ctx context.Context, in *Link, opts ...grpc.CallOption) (*Link, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Link)
	err := c.cc.Invoke(ctx, API_LinkUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) LinkGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Link, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Link)
	err := c.cc.Invoke(ctx, API_LinkGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) LinkQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Links, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Links)
	err := c.cc.Invoke(ctx, API_LinkQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) LogGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Log, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Log)
	err := c.cc.Invoke(ctx, API_LogGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) LogQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Logs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Logs)
	err := c.cc.Invoke(ctx, API_LogQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) MovementUpdate(ctx context.Context, in *Movement, opts ...grpc.CallOption) (*Movement, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Movement)
	err := c.cc.Invoke(ctx, API_MovementUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) MovementGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Movement, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Movement)
	err := c.cc.Invoke(ctx, API_MovementGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) MovementQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Movements, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Movements)
	err := c.cc.Invoke(ctx, API_MovementQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PaymentUpdate(ctx context.Context, in *Payment, opts ...grpc.CallOption) (*Payment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payment)
	err := c.cc.Invoke(ctx, API_PaymentUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PaymentGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Payment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payment)
	err := c.cc.Invoke(ctx, API_PaymentGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PaymentQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Payments, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Payments)
	err := c.cc.Invoke(ctx, API_PaymentQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PlaceUpdate(ctx context.Context, in *Place, opts ...grpc.CallOption) (*Place, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Place)
	err := c.cc.Invoke(ctx, API_PlaceUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PlaceGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Place, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Place)
	err := c.cc.Invoke(ctx, API_PlaceGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PlaceQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Places, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Places)
	err := c.cc.Invoke(ctx, API_PlaceQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PriceUpdate(ctx context.Context, in *Price, opts ...grpc.CallOption) (*Price, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Price)
	err := c.cc.Invoke(ctx, API_PriceUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PriceGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Price, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Price)
	err := c.cc.Invoke(ctx, API_PriceGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PriceQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Prices, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prices)
	err := c.cc.Invoke(ctx, API_PriceQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProductUpdate(ctx context.Context, in *Product, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, API_ProductUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProductGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, API_ProductGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProductQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Products, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Products)
	err := c.cc.Invoke(ctx, API_ProductQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProjectUpdate(ctx context.Context, in *Project, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, API_ProjectUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProjectGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, API_ProjectGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProjectQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Projects, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Projects)
	err := c.cc.Invoke(ctx, API_ProjectQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RateUpdate(ctx context.Context, in *Rate, opts ...grpc.CallOption) (*Rate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rate)
	err := c.cc.Invoke(ctx, API_RateUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RateGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Rate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rate)
	err := c.cc.Invoke(ctx, API_RateGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RateQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Rates, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Rates)
	err := c.cc.Invoke(ctx, API_RateQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TaxUpdate(ctx context.Context, in *Tax, opts ...grpc.CallOption) (*Tax, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tax)
	err := c.cc.Invoke(ctx, API_TaxUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TaxGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Tax, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tax)
	err := c.cc.Invoke(ctx, API_TaxGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TaxQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Taxes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Taxes)
	err := c.cc.Invoke(ctx, API_TaxQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ToolUpdate(ctx context.Context, in *Tool, opts ...grpc.CallOption) (*Tool, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tool)
	err := c.cc.Invoke(ctx, API_ToolUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ToolGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Tool, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tool)
	err := c.cc.Invoke(ctx, API_ToolGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ToolQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Tools, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Tools)
	err := c.cc.Invoke(ctx, API_ToolQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TransUpdate(ctx context.Context, in *Trans, opts ...grpc.CallOption) (*Trans, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Trans)
	err := c.cc.Invoke(ctx, API_TransUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TransGet(ctx context.Context, in *RequestGet, opts ...grpc.CallOption) (*Trans, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Trans)
	err := c.cc.Invoke(ctx, API_TransGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) TransQuery(ctx context.Context, in *RequestQuery, opts ...grpc.CallOption) (*Transactions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Transactions)
	err := c.cc.Invoke(ctx, API_TransQuery_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
// All implementations must embed UnimplementedAPIServer
// for forward compatibility.
//
// Nervatura gRPC API
type APIServer interface {
	// Login by username and password and get access token
	AuthLogin(context.Context, *RequestAuthLogin) (*ResponseAuthLogin, error)
	// Update or create user account.
	// If id or existing code is set, the user is updated, otherwise a new user is created.
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthUpdate(context.Context, *Auth) (*Auth, error)
	// Get user account by database id or code (unique key)
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthGet(context.Context, *RequestGet) (*Auth, error)
	// Change token user password
	AuthPassword(context.Context, *RequestPasswordChange) (*ResponseStatus, error)
	// Reset a user password and result a new password
	// If user is not admin, the user id and code are set to the current token user id or code
	AuthPasswordReset(context.Context, *RequestGet) (*ResponseStatus, error)
	// Login by access token. Returns token user
	TokenLogin(context.Context, *RequestEmpty) (*Auth, error)
	// Refresh access token
	TokenRefresh(context.Context, *RequestEmpty) (*ResponseAuthLogin, error)
	// Decode JWT access token but doesn't validate the signature
	TokenDecode(context.Context, *RequestTokenDecode) (*ResponseTokenDecode, error)
	// Create new nervatura database schema
	Database(context.Context, *RequestDatabase) (*JsonBytes, error)
	// Delete data by database id or code (unique key)
	// Only admin users can delete configurations except for CONFIG_PRINT_QUEUE and CONFIG_PATTERN
	// Auth user cannot be deleted, only disabled by admin users
	Delete(context.Context, *RequestDelete) (*ResponseStatus, error)
	// Call a server side function and get the result
	// Example: create new PDF invoice, send email or get a product price
	Function(context.Context, *RequestFunction) (*JsonBytes, error)
	// Get a predefined view by name
	View(context.Context, *RequestView) (*JsonBytes, error)
	// Update (replace) or create configuration
	// If id or existing code is set, the configuration is updated, otherwise a new configuration is created.
	// Only admin users can create or update configurations except for CONFIG_PRINT_QUEUE and CONFIG_PATTERN
	ConfigUpdate(context.Context, *Config) (*Config, error)
	// Get configuration by database id or code (unique key)
	ConfigGet(context.Context, *RequestGet) (*Config, error)
	// Get configurations by query parameters
	// Valid filters: config_type
	ConfigQuery(context.Context, *RequestQuery) (*Configs, error)
	// Update (replace) or create currency
	// If id or existing code is set, the currency is updated, otherwise a new currency is created.
	CurrencyUpdate(context.Context, *Currency) (*Currency, error)
	// Get currency by database id or code (unique key)
	CurrencyGet(context.Context, *RequestGet) (*Currency, error)
	// Get currencies by query parameters
	// Valid filters: tag
	CurrencyQuery(context.Context, *RequestQuery) (*Currencies, error)
	// Update (replace) or create customer
	// If id or existing code is set, the customer is updated, otherwise a new customer is created.
	CustomerUpdate(context.Context, *Customer) (*Customer, error)
	// Get customer by database id or code (unique key)
	CustomerGet(context.Context, *RequestGet) (*Customer, error)
	// Get customers by query parameters
	// Valid filters: customer_type, customer_name, tag
	CustomerQuery(context.Context, *RequestQuery) (*Customers, error)
	// Update (replace) or create employee
	// If id or existing code is set, the employee is updated, otherwise a new employee is created.
	EmployeeUpdate(context.Context, *Employee) (*Employee, error)
	// Get employee by database id or code (unique key)
	EmployeeGet(context.Context, *RequestGet) (*Employee, error)
	// Get employees by query parameters
	// Valid filters: tag
	EmployeeQuery(context.Context, *RequestQuery) (*Employees, error)
	// Update (replace) or create item
	// If id or existing code is set, the item is updated, otherwise a new item is created.
	ItemUpdate(context.Context, *Item) (*Item, error)
	// Get item by database id or code (unique key)
	ItemGet(context.Context, *RequestGet) (*Item, error)
	// Get items by query parameters
	// Valid filters: trans_code, product_code, tag
	ItemQuery(context.Context, *RequestQuery) (*Items, error)
	// Update (replace) or create link
	// If id or existing code is set, the link is updated, otherwise a new link is created.
	LinkUpdate(context.Context, *Link) (*Link, error)
	// Get link by database id or code (unique key)
	LinkGet(context.Context, *RequestGet) (*Link, error)
	// Get links by query parameters
	// Valid filters: link_type_1, link_code_1, link_type_2, link_code_2, tag
	LinkQuery(context.Context, *RequestQuery) (*Links, error)
	// Get log by database id or code (unique key)
	LogGet(context.Context, *RequestGet) (*Log, error)
	// Get logs by query parameters
	// Valid filters: log_type, ref_type, ref_code, tag
	LogQuery(context.Context, *RequestQuery) (*Logs, error)
	// Update (replace) or create movement
	// If id or existing code is set, the movement is updated, otherwise a new movement is created.
	MovementUpdate(context.Context, *Movement) (*Movement, error)
	// Get movement by database id or code (unique key)
	MovementGet(context.Context, *RequestGet) (*Movement, error)
	// Get movements by query parameters
	// Valid filters: trans_code, movement_type, tag
	MovementQuery(context.Context, *RequestQuery) (*Movements, error)
	// Update (replace) or create payment
	// If id or existing code is set, the payment is updated, otherwise a new payment is created.
	PaymentUpdate(context.Context, *Payment) (*Payment, error)
	// Get payment by database id or code (unique key)
	PaymentGet(context.Context, *RequestGet) (*Payment, error)
	// Get payments by query parameters
	// Valid filters: trans_code, paid_date, tag
	PaymentQuery(context.Context, *RequestQuery) (*Payments, error)
	// Update (replace) or create place
	// If id or existing code is set, the place is updated, otherwise a new place is created.
	PlaceUpdate(context.Context, *Place) (*Place, error)
	// Get place by database id or code (unique key)
	PlaceGet(context.Context, *RequestGet) (*Place, error)
	// Get places by query parameters
	// Valid filters: place_type, place_name, tag
	PlaceQuery(context.Context, *RequestQuery) (*Places, error)
	// Update (replace) or create price
	// If id or existing code is set, the price is updated, otherwise a new price is created.
	PriceUpdate(context.Context, *Price) (*Price, error)
	// Get price by database id or code (unique key)
	PriceGet(context.Context, *RequestGet) (*Price, error)
	// Get prices by query parameters
	// Valid filters: price_type, product_code, currency_code, customer_code, tag
	PriceQuery(context.Context, *RequestQuery) (*Prices, error)
	// Update (replace) or create product
	// If id or existing code is set, the product is updated, otherwise a new product is created.
	ProductUpdate(context.Context, *Product) (*Product, error)
	// Get product by database id or code (unique key)
	ProductGet(context.Context, *RequestGet) (*Product, error)
	// Get products by query parameters
	// Valid filters: product_type, product_name, tag
	ProductQuery(context.Context, *RequestQuery) (*Products, error)
	// Update (replace) or create project
	// If id or existing code is set, the project is updated, otherwise a new project is created.
	ProjectUpdate(context.Context, *Project) (*Project, error)
	// Get project by database id or code (unique key)
	ProjectGet(context.Context, *RequestGet) (*Project, error)
	// Get projects by query parameters
	// Valid filters: project_name, customer_code, tag
	ProjectQuery(context.Context, *RequestQuery) (*Projects, error)
	// Update (replace) or create rate
	// If id or existing code is set, the rate is updated, otherwise a new rate is created.
	RateUpdate(context.Context, *Rate) (*Rate, error)
	// Get rate by database id or code (unique key)
	RateGet(context.Context, *RequestGet) (*Rate, error)
	// Get rates by query parameters
	// Valid filters: rate_type, currency_code, tag
	RateQuery(context.Context, *RequestQuery) (*Rates, error)
	// Update (replace) or create tax
	// If id or existing code is set, the tax is updated, otherwise a new tax is created.
	TaxUpdate(context.Context, *Tax) (*Tax, error)
	// Get tax by database id or code (unique key)
	TaxGet(context.Context, *RequestGet) (*Tax, error)
	// Get taxes by query parameters
	// Valid filters: tag
	TaxQuery(context.Context, *RequestQuery) (*Taxes, error)
	// Update (replace) or create tool
	// If id or existing code is set, the tool is updated, otherwise a new tool is created.
	ToolUpdate(context.Context, *Tool) (*Tool, error)
	// Get tool by database id or code (unique key)
	ToolGet(context.Context, *RequestGet) (*Tool, error)
	// Get tools by query parameters
	// Valid filters: product_code, description, tag
	ToolQuery(context.Context, *RequestQuery) (*Tools, error)
	// Update (replace) or create transaction
	// If id or existing code is set, the transaction is updated, otherwise a new transaction is created.
	TransUpdate(context.Context, *Trans) (*Trans, error)
	// Get transaction by database id or code (unique key)
	TransGet(context.Context, *RequestGet) (*Trans, error)
	// Get transactions by query parameters
	// Valid filters: trans_type, direction, trans_date, tag
	TransQuery(context.Context, *RequestQuery) (*Transactions, error)
	mustEmbedUnimplementedAPIServer()
}

// UnimplementedAPIServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAPIServer struct{}

func (UnimplementedAPIServer) AuthLogin(context.Context, *RequestAuthLogin) (*ResponseAuthLogin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthLogin not implemented")
}
func (UnimplementedAPIServer) AuthUpdate(context.Context, *Auth) (*Auth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthUpdate not implemented")
}
func (UnimplementedAPIServer) AuthGet(context.Context, *RequestGet) (*Auth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthGet not implemented")
}
func (UnimplementedAPIServer) AuthPassword(context.Context, *RequestPasswordChange) (*ResponseStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthPassword not implemented")
}
func (UnimplementedAPIServer) AuthPasswordReset(context.Context, *RequestGet) (*ResponseStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthPasswordReset not implemented")
}
func (UnimplementedAPIServer) TokenLogin(context.Context, *RequestEmpty) (*Auth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenLogin not implemented")
}
func (UnimplementedAPIServer) TokenRefresh(context.Context, *RequestEmpty) (*ResponseAuthLogin, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenRefresh not implemented")
}
func (UnimplementedAPIServer) TokenDecode(context.Context, *RequestTokenDecode) (*ResponseTokenDecode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenDecode not implemented")
}
func (UnimplementedAPIServer) Database(context.Context, *RequestDatabase) (*JsonBytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Database not implemented")
}
func (UnimplementedAPIServer) Delete(context.Context, *RequestDelete) (*ResponseStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAPIServer) Function(context.Context, *RequestFunction) (*JsonBytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Function not implemented")
}
func (UnimplementedAPIServer) View(context.Context, *RequestView) (*JsonBytes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method View not implemented")
}
func (UnimplementedAPIServer) ConfigUpdate(context.Context, *Config) (*Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdate not implemented")
}
func (UnimplementedAPIServer) ConfigGet(context.Context, *RequestGet) (*Config, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGet not implemented")
}
func (UnimplementedAPIServer) ConfigQuery(context.Context, *RequestQuery) (*Configs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigQuery not implemented")
}
func (UnimplementedAPIServer) CurrencyUpdate(context.Context, *Currency) (*Currency, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrencyUpdate not implemented")
}
func (UnimplementedAPIServer) CurrencyGet(context.Context, *RequestGet) (*Currency, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrencyGet not implemented")
}
func (UnimplementedAPIServer) CurrencyQuery(context.Context, *RequestQuery) (*Currencies, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrencyQuery not implemented")
}
func (UnimplementedAPIServer) CustomerUpdate(context.Context, *Customer) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CustomerUpdate not implemented")
}
func (UnimplementedAPIServer) CustomerGet(context.Context, *RequestGet) (*Customer, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CustomerGet not implemented")
}
func (UnimplementedAPIServer) CustomerQuery(context.Context, *RequestQuery) (*Customers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CustomerQuery not implemented")
}
func (UnimplementedAPIServer) EmployeeUpdate(context.Context, *Employee) (*Employee, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmployeeUpdate not implemented")
}
func (UnimplementedAPIServer) EmployeeGet(context.Context, *RequestGet) (*Employee, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmployeeGet not implemented")
}
func (UnimplementedAPIServer) EmployeeQuery(context.Context, *RequestQuery) (*Employees, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmployeeQuery not implemented")
}
func (UnimplementedAPIServer) ItemUpdate(context.Context, *Item) (*Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemUpdate not implemented")
}
func (UnimplementedAPIServer) ItemGet(context.Context, *RequestGet) (*Item, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemGet not implemented")
}
func (UnimplementedAPIServer) ItemQuery(context.Context, *RequestQuery) (*Items, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ItemQuery not implemented")
}
func (UnimplementedAPIServer) LinkUpdate(context.Context, *Link) (*Link, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkUpdate not implemented")
}
func (UnimplementedAPIServer) LinkGet(context.Context, *RequestGet) (*Link, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkGet not implemented")
}
func (UnimplementedAPIServer) LinkQuery(context.Context, *RequestQuery) (*Links, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkQuery not implemented")
}
func (UnimplementedAPIServer) LogGet(context.Context, *RequestGet) (*Log, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogGet not implemented")
}
func (UnimplementedAPIServer) LogQuery(context.Context, *RequestQuery) (*Logs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogQuery not implemented")
}
func (UnimplementedAPIServer) MovementUpdate(context.Context, *Movement) (*Movement, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovementUpdate not implemented")
}
func (UnimplementedAPIServer) MovementGet(context.Context, *RequestGet) (*Movement, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovementGet not implemented")
}
func (UnimplementedAPIServer) MovementQuery(context.Context, *RequestQuery) (*Movements, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MovementQuery not implemented")
}
func (UnimplementedAPIServer) PaymentUpdate(context.Context, *Payment) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentUpdate not implemented")
}
func (UnimplementedAPIServer) PaymentGet(context.Context, *RequestGet) (*Payment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentGet not implemented")
}
func (UnimplementedAPIServer) PaymentQuery(context.Context, *RequestQuery) (*Payments, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PaymentQuery not implemented")
}
func (UnimplementedAPIServer) PlaceUpdate(context.Context, *Place) (*Place, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceUpdate not implemented")
}
func (UnimplementedAPIServer) PlaceGet(context.Context, *RequestGet) (*Place, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceGet not implemented")
}
func (UnimplementedAPIServer) PlaceQuery(context.Context, *RequestQuery) (*Places, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlaceQuery not implemented")
}
func (UnimplementedAPIServer) PriceUpdate(context.Context, *Price) (*Price, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PriceUpdate not implemented")
}
func (UnimplementedAPIServer) PriceGet(context.Context, *RequestGet) (*Price, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PriceGet not implemented")
}
func (UnimplementedAPIServer) PriceQuery(context.Context, *RequestQuery) (*Prices, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PriceQuery not implemented")
}
func (UnimplementedAPIServer) ProductUpdate(context.Context, *Product) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductUpdate not implemented")
}
func (UnimplementedAPIServer) ProductGet(context.Context, *RequestGet) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductGet not implemented")
}
func (UnimplementedAPIServer) ProductQuery(context.Context, *RequestQuery) (*Products, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProductQuery not implemented")
}
func (UnimplementedAPIServer) ProjectUpdate(context.Context, *Project) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectUpdate not implemented")
}
func (UnimplementedAPIServer) ProjectGet(context.Context, *RequestGet) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectGet not implemented")
}
func (UnimplementedAPIServer) ProjectQuery(context.Context, *RequestQuery) (*Projects, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectQuery not implemented")
}
func (UnimplementedAPIServer) RateUpdate(context.Context, *Rate) (*Rate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateUpdate not implemented")
}
func (UnimplementedAPIServer) RateGet(context.Context, *RequestGet) (*Rate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateGet not implemented")
}
func (UnimplementedAPIServer) RateQuery(context.Context, *RequestQuery) (*Rates, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateQuery not implemented")
}
func (UnimplementedAPIServer) TaxUpdate(context.Context, *Tax) (*Tax, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaxUpdate not implemented")
}
func (UnimplementedAPIServer) TaxGet(context.Context, *RequestGet) (*Tax, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaxGet not implemented")
}
func (UnimplementedAPIServer) TaxQuery(context.Context, *RequestQuery) (*Taxes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaxQuery not implemented")
}
func (UnimplementedAPIServer) ToolUpdate(context.Context, *Tool) (*Tool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToolUpdate not implemented")
}
func (UnimplementedAPIServer) ToolGet(context.Context, *RequestGet) (*Tool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToolGet not implemented")
}
func (UnimplementedAPIServer) ToolQuery(context.Context, *RequestQuery) (*Tools, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToolQuery not implemented")
}
func (UnimplementedAPIServer) TransUpdate(context.Context, *Trans) (*Trans, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransUpdate not implemented")
}
func (UnimplementedAPIServer) TransGet(context.Context, *RequestGet) (*Trans, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransGet not implemented")
}
func (UnimplementedAPIServer) TransQuery(context.Context, *RequestQuery) (*Transactions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransQuery not implemented")
}
func (UnimplementedAPIServer) mustEmbedUnimplementedAPIServer() {}
func (UnimplementedAPIServer) testEmbeddedByValue()             {}

// UnsafeAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to APIServer will
// result in compilation errors.
type UnsafeAPIServer interface {
	mustEmbedUnimplementedAPIServer()
}

func RegisterAPIServer(s grpc.ServiceRegistrar, srv APIServer) {
	// If the following call pancis, it indicates UnimplementedAPIServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&API_ServiceDesc, srv)
}

func _API_AuthLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAuthLogin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AuthLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_AuthLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AuthLogin(ctx, req.(*RequestAuthLogin))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_AuthUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Auth)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AuthUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_AuthUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AuthUpdate(ctx, req.(*Auth))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_AuthGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AuthGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_AuthGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AuthGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_AuthPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestPasswordChange)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AuthPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_AuthPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AuthPassword(ctx, req.(*RequestPasswordChange))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_AuthPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AuthPasswordReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_AuthPasswordReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AuthPasswordReset(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEmpty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TokenLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenLogin(ctx, req.(*RequestEmpty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenRefresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEmpty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenRefresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TokenRefresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenRefresh(ctx, req.(*RequestEmpty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TokenDecode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTokenDecode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TokenDecode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TokenDecode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TokenDecode(ctx, req.(*RequestTokenDecode))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Database_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDatabase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Database(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_Database_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Database(ctx, req.(*RequestDatabase))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDelete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Delete(ctx, req.(*RequestDelete))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Function_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestFunction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Function(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_Function_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Function(ctx, req.(*RequestFunction))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_View_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestView)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).View(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_View_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).View(ctx, req.(*RequestView))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ConfigUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ConfigUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ConfigUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ConfigUpdate(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ConfigGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ConfigGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ConfigGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ConfigGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ConfigQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ConfigQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ConfigQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ConfigQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CurrencyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CurrencyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CurrencyUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CurrencyUpdate(ctx, req.(*Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CurrencyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CurrencyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CurrencyGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CurrencyGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CurrencyQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CurrencyQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CurrencyQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CurrencyQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CustomerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Customer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CustomerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CustomerUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CustomerUpdate(ctx, req.(*Customer))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CustomerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CustomerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CustomerGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CustomerGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CustomerQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CustomerQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CustomerQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CustomerQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_EmployeeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Employee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).EmployeeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_EmployeeUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).EmployeeUpdate(ctx, req.(*Employee))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_EmployeeGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).EmployeeGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_EmployeeGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).EmployeeGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_EmployeeQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).EmployeeQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_EmployeeQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).EmployeeQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ItemUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Item)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ItemUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ItemUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ItemUpdate(ctx, req.(*Item))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ItemGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ItemGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ItemGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ItemGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ItemQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ItemQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ItemQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ItemQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_LinkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Link)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).LinkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_LinkUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).LinkUpdate(ctx, req.(*Link))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_LinkGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).LinkGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_LinkGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).LinkGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_LinkQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).LinkQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_LinkQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).LinkQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_LogGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).LogGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_LogGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).LogGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_LogQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).LogQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_LogQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).LogQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_MovementUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Movement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).MovementUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_MovementUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).MovementUpdate(ctx, req.(*Movement))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_MovementGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).MovementGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_MovementGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).MovementGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_MovementQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).MovementQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_MovementQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).MovementQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PaymentUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Payment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PaymentUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PaymentUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PaymentUpdate(ctx, req.(*Payment))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PaymentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PaymentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PaymentGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PaymentGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PaymentQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PaymentQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PaymentQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PaymentQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PlaceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Place)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PlaceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PlaceUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PlaceUpdate(ctx, req.(*Place))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PlaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PlaceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PlaceGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PlaceGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PlaceQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PlaceQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PlaceQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PlaceQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PriceUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Price)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PriceUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PriceUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PriceUpdate(ctx, req.(*Price))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PriceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PriceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PriceGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PriceGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PriceQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PriceQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_PriceQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PriceQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProductUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Product)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProductUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProductUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProductUpdate(ctx, req.(*Product))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProductGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProductGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProductGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProductGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProductQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProductQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProductQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProductQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProjectUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Project)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProjectUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProjectUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProjectUpdate(ctx, req.(*Project))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProjectGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProjectGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProjectGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProjectGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProjectQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ProjectQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ProjectQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ProjectQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RateUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RateUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_RateUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RateUpdate(ctx, req.(*Rate))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RateGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RateGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_RateGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RateGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RateQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RateQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_RateQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RateQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TaxUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tax)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TaxUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TaxUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TaxUpdate(ctx, req.(*Tax))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TaxGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TaxGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TaxGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TaxGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TaxQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TaxQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TaxQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TaxQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ToolUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ToolUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ToolUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ToolUpdate(ctx, req.(*Tool))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ToolGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ToolGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ToolGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ToolGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ToolQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ToolQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_ToolQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ToolQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TransUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Trans)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TransUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TransUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TransUpdate(ctx, req.(*Trans))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TransGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TransGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TransGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TransGet(ctx, req.(*RequestGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_TransQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).TransQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_TransQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).TransQuery(ctx, req.(*RequestQuery))
	}
	return interceptor(ctx, in, info, handler)
}

// API_ServiceDesc is the grpc.ServiceDesc for API service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var API_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nervatura.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthLogin",
			Handler:    _API_AuthLogin_Handler,
		},
		{
			MethodName: "AuthUpdate",
			Handler:    _API_AuthUpdate_Handler,
		},
		{
			MethodName: "AuthGet",
			Handler:    _API_AuthGet_Handler,
		},
		{
			MethodName: "AuthPassword",
			Handler:    _API_AuthPassword_Handler,
		},
		{
			MethodName: "AuthPasswordReset",
			Handler:    _API_AuthPasswordReset_Handler,
		},
		{
			MethodName: "TokenLogin",
			Handler:    _API_TokenLogin_Handler,
		},
		{
			MethodName: "TokenRefresh",
			Handler:    _API_TokenRefresh_Handler,
		},
		{
			MethodName: "TokenDecode",
			Handler:    _API_TokenDecode_Handler,
		},
		{
			MethodName: "Database",
			Handler:    _API_Database_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _API_Delete_Handler,
		},
		{
			MethodName: "Function",
			Handler:    _API_Function_Handler,
		},
		{
			MethodName: "View",
			Handler:    _API_View_Handler,
		},
		{
			MethodName: "ConfigUpdate",
			Handler:    _API_ConfigUpdate_Handler,
		},
		{
			MethodName: "ConfigGet",
			Handler:    _API_ConfigGet_Handler,
		},
		{
			MethodName: "ConfigQuery",
			Handler:    _API_ConfigQuery_Handler,
		},
		{
			MethodName: "CurrencyUpdate",
			Handler:    _API_CurrencyUpdate_Handler,
		},
		{
			MethodName: "CurrencyGet",
			Handler:    _API_CurrencyGet_Handler,
		},
		{
			MethodName: "CurrencyQuery",
			Handler:    _API_CurrencyQuery_Handler,
		},
		{
			MethodName: "CustomerUpdate",
			Handler:    _API_CustomerUpdate_Handler,
		},
		{
			MethodName: "CustomerGet",
			Handler:    _API_CustomerGet_Handler,
		},
		{
			MethodName: "CustomerQuery",
			Handler:    _API_CustomerQuery_Handler,
		},
		{
			MethodName: "EmployeeUpdate",
			Handler:    _API_EmployeeUpdate_Handler,
		},
		{
			MethodName: "EmployeeGet",
			Handler:    _API_EmployeeGet_Handler,
		},
		{
			MethodName: "EmployeeQuery",
			Handler:    _API_EmployeeQuery_Handler,
		},
		{
			MethodName: "ItemUpdate",
			Handler:    _API_ItemUpdate_Handler,
		},
		{
			MethodName: "ItemGet",
			Handler:    _API_ItemGet_Handler,
		},
		{
			MethodName: "ItemQuery",
			Handler:    _API_ItemQuery_Handler,
		},
		{
			MethodName: "LinkUpdate",
			Handler:    _API_LinkUpdate_Handler,
		},
		{
			MethodName: "LinkGet",
			Handler:    _API_LinkGet_Handler,
		},
		{
			MethodName: "LinkQuery",
			Handler:    _API_LinkQuery_Handler,
		},
		{
			MethodName: "LogGet",
			Handler:    _API_LogGet_Handler,
		},
		{
			MethodName: "LogQuery",
			Handler:    _API_LogQuery_Handler,
		},
		{
			MethodName: "MovementUpdate",
			Handler:    _API_MovementUpdate_Handler,
		},
		{
			MethodName: "MovementGet",
			Handler:    _API_MovementGet_Handler,
		},
		{
			MethodName: "MovementQuery",
			Handler:    _API_MovementQuery_Handler,
		},
		{
			MethodName: "PaymentUpdate",
			Handler:    _API_PaymentUpdate_Handler,
		},
		{
			MethodName: "PaymentGet",
			Handler:    _API_PaymentGet_Handler,
		},
		{
			MethodName: "PaymentQuery",
			Handler:    _API_PaymentQuery_Handler,
		},
		{
			MethodName: "PlaceUpdate",
			Handler:    _API_PlaceUpdate_Handler,
		},
		{
			MethodName: "PlaceGet",
			Handler:    _API_PlaceGet_Handler,
		},
		{
			MethodName: "PlaceQuery",
			Handler:    _API_PlaceQuery_Handler,
		},
		{
			MethodName: "PriceUpdate",
			Handler:    _API_PriceUpdate_Handler,
		},
		{
			MethodName: "PriceGet",
			Handler:    _API_PriceGet_Handler,
		},
		{
			MethodName: "PriceQuery",
			Handler:    _API_PriceQuery_Handler,
		},
		{
			MethodName: "ProductUpdate",
			Handler:    _API_ProductUpdate_Handler,
		},
		{
			MethodName: "ProductGet",
			Handler:    _API_ProductGet_Handler,
		},
		{
			MethodName: "ProductQuery",
			Handler:    _API_ProductQuery_Handler,
		},
		{
			MethodName: "ProjectUpdate",
			Handler:    _API_ProjectUpdate_Handler,
		},
		{
			MethodName: "ProjectGet",
			Handler:    _API_ProjectGet_Handler,
		},
		{
			MethodName: "ProjectQuery",
			Handler:    _API_ProjectQuery_Handler,
		},
		{
			MethodName: "RateUpdate",
			Handler:    _API_RateUpdate_Handler,
		},
		{
			MethodName: "RateGet",
			Handler:    _API_RateGet_Handler,
		},
		{
			MethodName: "RateQuery",
			Handler:    _API_RateQuery_Handler,
		},
		{
			MethodName: "TaxUpdate",
			Handler:    _API_TaxUpdate_Handler,
		},
		{
			MethodName: "TaxGet",
			Handler:    _API_TaxGet_Handler,
		},
		{
			MethodName: "TaxQuery",
			Handler:    _API_TaxQuery_Handler,
		},
		{
			MethodName: "ToolUpdate",
			Handler:    _API_ToolUpdate_Handler,
		},
		{
			MethodName: "ToolGet",
			Handler:    _API_ToolGet_Handler,
		},
		{
			MethodName: "ToolQuery",
			Handler:    _API_ToolQuery_Handler,
		},
		{
			MethodName: "TransUpdate",
			Handler:    _API_TransUpdate_Handler,
		},
		{
			MethodName: "TransGet",
			Handler:    _API_TransGet_Handler,
		},
		{
			MethodName: "TransQuery",
			Handler:    _API_TransQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/service/grpc/proto/store.proto",
}
